---
import { getCollection } from 'astro:content';
import Layout from '../../layouts/Layout.astro';
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';
import { marked } from 'marked';

// Convert slug to title: "test-local-post" -> "Test Local Post"
function slugToTitle(slug: string): string {
  return slug
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Generate table of contents from markdown
function generateTOC(markdown: string) {
  const lines = markdown.split('\n');
  const toc: Array<{ level: number; text: string; id: string }> = [];
  
  lines.forEach(line => {
    const h2Match = line.match(/^## (.+)$/);
    const h3Match = line.match(/^### (.+)$/);
    
    if (h2Match) {
      const text = h2Match[1].trim();
      const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
      toc.push({ level: 2, text, id });
    } else if (h3Match) {
      const text = h3Match[1].trim();
      const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
      toc.push({ level: 3, text, id });
    }
  });
  
  return toc;
}

export async function getStaticPaths() {
  const posts = await getCollection('writing');
  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }));
}

const { post } = Astro.props;

// Read raw markdown to generate TOC and render with TOC support
let toc: Array<{ level: number; text: string; id: string }> = [];
let processedHtml = '';
let hasTOC = false;
let useCustomRender = false;

try {
  const filePath = join(process.cwd(), 'src', 'content', 'writing', post.id);
  const rawMarkdown = await readFile(filePath, 'utf-8');
  toc = generateTOC(rawMarkdown);
  hasTOC = toc.length > 0;
  
  // If we have headings, render with marked and process for TOC
  if (hasTOC) {
    useCustomRender = true;
    // Render markdown to HTML
    let html = await marked(rawMarkdown);
    
    // Add IDs to headings and back-to-TOC links
    // Process in reverse order to avoid replacing already-processed headings
    for (let i = toc.length - 1; i >= 0; i--) {
      const item = toc[i];
      const headingTag = item.level === 2 ? 'h2' : 'h3';
      
      // Escape special regex characters in the text (but not apostrophes/quotes which might be HTML entities)
      const escapedText = item.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      
      // Create patterns that match both the original text and potential HTML entities
      // Marked might convert apostrophes to &#39; or &apos;
      const textPatterns = [
        escapedText, // Original text
        escapedText.replace(/'/g, '(&#39;|&apos;|\')'), // Apostrophe variations
      ];
      
      // Try each pattern
      for (const textPattern of textPatterns) {
        // Create a flexible regex that matches the heading with optional whitespace
        const regex = new RegExp(`<${headingTag}([^>]*)>\\s*${textPattern}\\s*</${headingTag}>`, 'gi');
        
        if (regex.test(html)) {
          regex.lastIndex = 0; // Reset regex
          html = html.replace(regex, (match, attrs) => {
            // Only add id if it doesn't already exist
            const hasId = attrs && attrs.includes('id=');
            const idAttr = hasId ? '' : ` id="${item.id}"`;
            // Preserve existing attributes
            const finalAttrs = attrs ? attrs + idAttr : idAttr;
            return `<${headingTag}${finalAttrs}>${item.text} <a href="#toc" class="back-to-toc">↑ back to TOC</a></${headingTag}>`;
          });
          break; // Found and replaced, move to next item
        }
      }
    }
    
    processedHtml = html;
  }
} catch (error) {
  // If we can't read the file, just render normally
  console.error('Error reading post file:', error);
}

// Always render with Astro's Content component as fallback
const { Content } = await post.render();
const title = slugToTitle(post.slug);
---

<Layout title={title}>
  <article>
    <h1>{title}</h1>
    
    {hasTOC && toc.length > 0 && (
      <div class="toc" id="toc">
        <h3 class="toc-header" id="toc-header">
          Table of Contents
          <span class="toc-toggle">▼</span>
        </h3>
        <ul class="toc-list" id="toc-list">
          {toc.map(item => (
            <li class={`toc-level-${item.level}`}>
              <a href={`#${item.id}`}>{item.text}</a>
            </li>
          ))}
        </ul>
      </div>
    )}
    
    {useCustomRender && processedHtml ? (
      <div class="markdown-content" set:html={processedHtml}></div>
    ) : (
      <Content />
    )}
  </article>
</Layout>

<style>
  .toc {
    background: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    margin-top: 2rem;
  }
  
  .toc-header {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .toc-header:hover {
    color: #666;
  }
  
  .toc-toggle {
    font-size: 0.8em;
    transition: transform 0.2s;
  }
  
  .toc.collapsed .toc-toggle {
    transform: rotate(-90deg);
  }
  
  .toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 1000px;
    opacity: 1;
    transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
    overflow: hidden;
  }
  
  .toc.collapsed .toc-list {
    max-height: 0;
    opacity: 0;
    margin: 0;
  }
  
  .toc li {
    margin-bottom: 0.5rem;
  }
  
  .toc-level-2 {
    font-weight: 600;
  }
  
  .toc-level-3 {
    padding-left: 1.5rem;
    font-weight: normal;
    font-size: 0.95em;
  }
  
  .toc a {
    color: #1a1a1a;
    text-decoration: none;
  }
  
  .toc a:hover {
    text-decoration: underline;
  }
  
  :global(.markdown-content) {
    line-height: 1.8;
  }
  
  :global(.markdown-content h2),
  :global(.markdown-content h3) {
    scroll-margin-top: 20px;
  }
  
  :global(.markdown-content h2),
  :global(.markdown-content h3) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  
  :global(.back-to-toc) {
    font-size: 0.7em;
    font-weight: normal;
    color: #666;
    text-decoration: none;
    margin-left: auto;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  
  :global(.back-to-toc:hover) {
    opacity: 1;
    text-decoration: underline;
  }
  
  :global(.markdown-content h2:hover .back-to-toc) {
    opacity: 1;
  }
</style>

{hasTOC && (
  <script is:inline>
    document.addEventListener('DOMContentLoaded', function() {
      const tocHeader = document.getElementById('toc-header');
      const toc = document.getElementById('toc');
      
      if (tocHeader && toc) {
        tocHeader.addEventListener('click', function() {
          toc.classList.toggle('collapsed');
        });
        
        // Make TOC collapsed by default on mobile, expanded on desktop
        if (window.innerWidth < 768) {
          toc.classList.add('collapsed');
        }
      }
    });
  </script>
)}